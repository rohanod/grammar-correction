The grammar correction tool uses a URL-based data format to encode the text and corrections. The data is passed as a query parameter in the URL.

There is one primary method for encoding the data:

A single `data` parameter that contains a base64-encoded JSON string.

## Inline Data Structure (Recommended for LLMs)

The new inline format eliminates the need for position calculations, making it much easier for LLMs to generate. The JSON object has the following structure:

```json
{
  "segments": [
    {
      "text": "word or phrase",
      "correction": {
        "type": "grammar" | "spelling" | "punctuation" | "word-choice" | "capitalization",
        "corrected": "the corrected version",
        "reason": "explanation of why the correction was made"
      }
    },
    {
      "text": "regular text without corrections"
    }
  ]
}
```

- `segments`: An array of text segments that make up the full text.

### Segment Object

Each segment represents a portion of the text:

- `text`: The text content of this segment. If this segment contains an error, this is the incorrect version.
- `correction` (optional): If present, indicates this segment contains a correction.

### Correction Object (within a segment)

- `type`: The category of the correction.
- `corrected`: The corrected version of the text (replaces the segment's `text` in the corrected view).
- `reason`: A brief explanation for the correction.

## Example (Inline Format)

Here is an example of the inline format:

```json
{
  "segments": [
    {
      "text": "helo",
      "correction": {
        "type": "spelling",
        "corrected": "Hello",
        "reason": "Spelling error - correct spelling is 'Hello'"
      }
    },
    {
      "text": " world! This "
    },
    {
      "text": "are",
      "correction": {
        "type": "grammar",
        "corrected": "is",
        "reason": "Subject-verb agreement - singular 'This' requires 'is'"
      }
    },
    {
      "text": " "
    },
    {
      "text": "a",
      "correction": {
        "type": "grammar",
        "corrected": "an",
        "reason": "Article correction - use 'an' before vowel sounds"
      }
    },
    {
      "text": " example of "
    },
    {
      "text": "grammer",
      "correction": {
        "type": "spelling",
        "corrected": "grammar",
        "reason": "Spelling error - correct spelling is 'grammar'"
      }
    },
    {
      "text": " corrections",
      "correction": {
        "type": "punctuation",
        "corrected": " corrections.",
        "reason": "Sentence should end with a period"
      }
    }
  ]
}
```

This JSON object would be base64-encoded and appended to the URL as the `data` query parameter.

## Legacy Data Structure (Position-Based)

The tool also supports a legacy format for backward compatibility:

```json
{
  "original": "The original text.",
  "corrected": "The corrected version of the text.",
  "corrections": [
    {
      "type": "grammar" | "spelling" | "punctuation" | "word-choice" | "capitalization",
      "original": "The incorrect word or phrase.",
      "corrected": "The corrected word or phrase.",
      "position": 0,
      "reason": "An explanation of why the correction was made."
    }
  ]
}
```

Note: The legacy format requires calculating exact character positions, which is error-prone for LLMs. The inline format is recommended instead.
